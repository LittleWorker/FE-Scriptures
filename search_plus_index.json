{"./":{"url":"./","title":"前言","keywords":"","body":"Introduction 《前端四十二章经》 web前端开发基础知识及技术点文章分享 wayofway all right reserved，powered by GitbookLast modified： 2020-07-08 17:06:40 "},"前端标准与规范/":{"url":"前端标准与规范/","title":"第一章：前端标准与规范","keywords":"","body":"Introduction 《前端四十二章经》 web前端开发基础知识及技术点文章分享 wayofway all right reserved，powered by GitbookLast modified： 2020-07-08 17:06:40 "},"前端标准与规范/html/":{"url":"前端标准与规范/html/","title":"第1节：HTML","keywords":"","body":"HTML wayofway all right reserved，powered by GitbookLast modified： 2020-07-08 17:06:40 "},"前端标准与规范/css/清除浮动.html":{"url":"前端标准与规范/css/清除浮动.html","title":"1. 清除浮动","keywords":"","body":"清除浮动 wayofway all right reserved，powered by GitbookLast modified： 2020-07-08 17:06:40 "},"编程语言/":{"url":"编程语言/","title":"第二章：编程语言","keywords":"","body":"Introduction 《前端四十二章经》 web前端开发基础知识及技术点文章分享 wayofway all right reserved，powered by GitbookLast modified： 2020-07-08 17:06:40 "},"编程语言/JavaScript/闭包.html":{"url":"编程语言/JavaScript/闭包.html","title":"1. 闭包","keywords":"","body":"闭包 wayofway all right reserved，powered by GitbookLast modified： 2020-07-08 17:06:40 "},"编程语言/JavaScript/防抖与节流.html":{"url":"编程语言/JavaScript/防抖与节流.html","title":"2. 防抖与节流","keywords":"","body":"防抖与节流 防抖 任务频繁触发的情况下，只有任务触发的间隔超过指定间隔的时候，任务才会执行。 方法实现 function debounce(fn, delay) { var timer; return function(args) { var _this = this; var _args = args; clearTimeout(timer); timer = setTimeout(function() { fn.apply(_this, _args); }, delay) } } // 箭头函数 function debounce(fn, delay) { let timer; return (...args)=>{ clearTimeout(timer) timer = setTimeout(()=>{ fn(...args) }, delay) } } 节流 指定时间间隔内只会执行一次任务； 方法实现 function throttle(fn, threshhold) { var timer; var lastTime = new Date(); return function(args) {~~~~ var _this = this; var _args = args; var now = new Date(); clearTimeout(timer) if (now - lastTime >= threshhold) { fn.apply(_this, _args); lastTime = now; } else { timer = setTimeout(function() { fn.apply(_this, _args); }, threshhold) } } } //箭头函数 function throttle(fn, delay) { let timer; let threshTime = new Date();; return (...args) => { let now = new Date(); clearTimeout(timer); if(threshTime && now - threshTime > delay) { threshTime = now; fn(...args); } else { timer = setTimeout(()=>{ fn(...args) }, delay); } } } wayofway all right reserved，powered by GitbookLast modified： 2020-07-08 17:06:40 "},"编程语言/JavaScript/事件循环.html":{"url":"编程语言/JavaScript/事件循环.html","title":"3. 事件循环","keywords":"","body":"事件循环 wayofway all right reserved，powered by GitbookLast modified： 2020-07-08 17:06:40 "},"编程语言/JavaScript/函数劫持.html":{"url":"编程语言/JavaScript/函数劫持.html","title":"4. 函数劫持","keywords":"","body":"函数劫持 https://juejin.im/post/5e61fdfc6fb9a07caf44685c 函数劫持的意思是在一个函数运行之前把它劫持下来，添加我们想要的功能，然后再调用原来的函数执行。这也是常见的钩子函数的原理之一。 应用 XSS攻击经常使用alert测试是否存在跨站，所以可以通过劫持alert函数来监测是否有人在攻击你的网站。在监测的页面劫持alert函数，记录调用情况。 function report(caller) { var img=new Image(); img.src=`http://www.site.com/getReport.php?caller=${encodeURIComponent(caller)}`; } var _alert = window.alert window.alert = function(s) { report(alert.caller) _alert(s) } 自定义业务功能。业务代码经常会有新需求的加入，对原代码进行修改匹配，常常比较耗费时间，这个时候就可以使用函数劫持，在不修改原业务逻辑的前提下，增加新功能。 判断某个函数是否被劫持 function foo() {console.log(foo);} alert.toString() // \"function alert() { [native code] }\" foo.toString() // \"function foo() {console.log(foo);}\" 复制代码 对于native代码内置函数如alert，输出打印时会显示为[native code]，而自定义的函数会显示函数定义的内容，通过这个方法可以检查函数是否被劫持。 注意到有一种伪装成native function的方式如下： var fakeAlert = (function(){}).bind(null); console.log(window.alert.toString()); // function alert() { [native code] } console.log(fakeAlert.toString()); // function () { [native code] } 复制代码 bind(null)伪装后的函数不带函数名，所以更严格的检查需要检查函数名是否为空。 如何反劫持 通常劫持的都是一些可以向用户反馈信息的API，如alert、eval、console.log等。这些native代码通常难以还原，所以可以通过还原出一个纯净的环境iframe，在iframe中调用相关函数。 function createIframe(w) { var d = w.document; var newIframe = d.createElement(\"iframe\"); newIframe.style.width = 0; newIframe.style.height = 0; d.body.appendChild(newIframe); newIframe.contentWindow.document.write(\"\"); return newIframe; } function injectScriptIntoIframe(f, proc) { var d = f.contentWindow.document; var s = \"\\n(\" + proc.toString() + \")();\\n\"; d.write(s); } 举个例子，对于涉及到反馈信息的API可以封装到函数中，调用方法在iframe中执行： // 将信息相关封装到函数中，在iframe中调用 function payload() { // your code goes here } var f = createIframe(top); injectScriptIntoIframe(f, payload); wayofway all right reserved，powered by GitbookLast modified： 2020-07-08 17:06:40 "},"算法与数据结构/":{"url":"算法与数据结构/","title":"第三章：算法与数据结构","keywords":"","body":"Introduction 《前端四十二章经》 web前端开发基础知识及技术点文章分享 wayofway all right reserved，powered by GitbookLast modified： 2020-07-08 17:06:40 "},"前端框架/":{"url":"前端框架/","title":"第四章：前端框架","keywords":"","body":"Introduction 《前端四十二章经》 web前端开发基础知识及技术点文章分享 wayofway all right reserved，powered by GitbookLast modified： 2020-07-08 17:06:40 "},"网络/":{"url":"网络/","title":"第五章：网络","keywords":"","body":"Introduction 《前端四十二章经》 web前端开发基础知识及技术点文章分享 wayofway all right reserved，powered by GitbookLast modified： 2020-07-08 17:06:40 "},"安全/":{"url":"安全/","title":"第六章：安全","keywords":"","body":"Introduction 《前端四十二章经》 web前端开发基础知识及技术点文章分享 wayofway all right reserved，powered by GitbookLast modified： 2020-07-08 17:06:40 "}}